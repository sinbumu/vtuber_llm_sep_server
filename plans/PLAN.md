# PLAN – Open-LLM-VTuber 분석 (상용 Unity 데스크탑 AI 비서 적용 관점)

> 목표: Open-LLM-VTuber(Open-LLM-VTuber + Open-LLM-VTuber-Unity)를 분석해서  
> **(1) MIT로 안전하게 재사용 가능한 범위**와 **(2) Unity에서 바로 가져다 쓸 코드 구간**을 뽑아낸다.  
> 최종적으로 “우리 Unity 데스크탑 AI 비서 MVP”에 적용 가능한 PoC 방향을 결정한다.

---

## 0. Meta

- 대상
  - 메인(백엔드/전체): https://github.com/Open-LLM-VTuber/Open-LLM-VTuber
  - Unity 서브레포: https://github.com/Open-LLM-VTuber/Open-LLM-VTuber-Unity
- 분석 핵심 질문
  - Q1. 메인 레포는 **v1.2.0까지 MIT**가 맞나? (태그/릴리스 기준으로 확정)
  - Q2. v1.2.0 이후 “Open-LLM-VTuber License 1.0”의 **상업적 사용 제한**이 무엇인가?
  - Q3. Unity 레포에서 **즉시 재사용 가능한 코드**는 무엇인가? (오디오/LLM 호출/Live2D 매핑)
  - Q4. 우리 프로젝트는 “Unity 앱”이므로, 백엔드를 **별도 프로세스로 둬야 하는지**(Python/Node) 판단

- 산출물 (노션 공유용)
  - [ ] 라이선스 결론(안전한 태그/커밋 SHA 포함)
  - [ ] 재사용 가능 코드 구간 Top5 + 파일 경로
  - [ ] 우리 앱에 붙이는 PoC 설계(1~2안)

---

## 1. 가져오기(중요: 태그 고정)

### 1-1. 메인 레포 클론 + v1.2.0 고정

- [ ] clone
- [ ] 태그/릴리스 목록 확인 (`git tag -l`)
- [ ] **v1.2.0 체크아웃**
- [ ] v1.2.0의 커밋 SHA 기록 (`git rev-parse HEAD`)

> Cursor 프롬프트
> - "이 레포의 릴리스/태그 중 v1.2.0이 존재하는지 확인하고, 해당 태그의 commit SHA를 알려줘."

### 1-2. Unity 레포 클론

- [ ] clone
- [ ] LICENSE 확인(MIT인지)
- [ ] 샘플 씬/플러그인/스크립트 구조 파악

---

## 2. 라이선스 확인(필수)

### 2-1. 메인 레포 (v1.2.0 기준)

- [ ] `LICENSE` 파일 확인
- [ ] v1.2.0의 LICENSE가 **MIT**인지 캡처/요약
- [ ] `NOTICE` / `ThirdParty` / `deps` 문서가 있으면 확인

### 2-2. v1.2.0 이후(라이선스 변경점 파악)

- [ ] main branch(또는 최신 릴리스)에서 LICENSE/라이선스 공지 확인
- [ ] “Open-LLM-VTuber License 1.0”의 핵심 제한사항 요약
  - 상업적 사용 가능 여부
  - 배포/재판매 제한 여부
  - “코드 파생물” 의무 사항(소스 공개 등) 여부

> Cursor 프롬프트
> - "v1.2.0 태그의 LICENSE 내용을 요약해줘. 상업적 사용 시 요구사항(저작권 표기 등)을 정리해줘."
> - "최신 브랜치에서 라이선스가 변경되었는지 확인하고, 변경점과 제한사항을 10줄 이내로 요약해줘."

> 결론 체크박스
- [ ] 우리 상용 프로젝트에서 **안전한 기준점**: v1.2.0 태그 고정
- [ ] v1.2.0 이후 코드는: [ ] 사용 가능 / [ ] 사용 보류(참고만)

---

## 3. 전체 구조 맵(빠르게)

### 3-1. 메인 레포 구조

- [ ] 최상위 디렉토리 구조를 표로 정리
- [ ] 핵심 컴포넌트(LLM/STT/TTS/Live2D/이벤트/설정) 위치 후보 파악

> Cursor 프롬프트
> - "최상위 폴더 구조를 요약하고 각 폴더 역할을 추정해줘."
> - "LLM, STT, TTS, Live2D, Unity 관련 키워드로 파일/폴더를 찾아서 카테고리별로 정리해줘."

### 3-2. Unity 레포 구조

- [ ] `Assets/` 내 주요 폴더/패키지/샘플 씬 확인
- [ ] Live2D Cubism 의존성 여부 확인
- [ ] 네트워크(HTTP/WebSocket) 연결 방식 확인

---

## 4. LLM 파이프라인 분석(메인 레포)

> 목적: Unity에서 “캐릭터 반응(표정/모션)”을 만들려면  
> LLM 응답을 **구조화(JSON)** 하거나 **감정 태깅**이 필요하다.

- [ ] 지원 LLM Provider 목록
- [ ] 프롬프트 구성 구조
  - system prompt / character prompt / memory / tool-calling 여부
- [ ] 응답 포맷
  - [ ] 단순 텍스트
  - [ ] JSON 스키마(감정/행동 태그)
  - [ ] 후처리로 감정 분석/분류 수행

> Cursor 프롬프트
> - "LLM을 호출하는 핵심 코드(함수/클래스)를 찾아서 입력(prompt 구성)과 출력(parsing) 흐름을 설명해줘."
> - "감정/행동 태그를 만들거나 JSON 출력 포맷을 강제하는 부분이 있으면 해당 파일 경로와 핵심 로직을 요약해줘."

---

## 5. STT/TTS 파이프라인(메인 레포)

- [ ] STT(Whisper 등) 사용 여부 / 실시간 처리 방식
- [ ] TTS 엔진(VoiceVox/Coqui/클라우드 TTS 등)
- [ ] 오디오 큐/인터럽트(말 끊기) 구현 여부
- [ ] 립싱크(입모양) 연결 방식이 있는지

> Cursor 프롬프트
> - "STT 관련 코드 위치와 입력 흐름(마이크→텍스트)을 정리해줘."
> - "TTS 관련 코드 위치와 출력 흐름(텍스트→음성)을 정리해줘."
> - "대화 중 인터럽트/바지니스(말 끊기) 제어가 있다면 어떻게 구현했는지 요약해줘."

---

## 6. Live2D/캐릭터 반응 연결 방식(가장 중요)

> 이 분석의 핵심: “LLM 응답 → 감정/행동 태그 → Live2D 표정/모션”

- [ ] 감정(emotion)/행동(action)/톤(tone) 같은 추상 태그가 존재하는가?
- [ ] 그 태그를 실제 Live2D 파라미터/모션으로 매핑하는 데이터가 있는가?
  - 예: JSON/CSV/ScriptableObject/코드 상 딕셔너리
- [ ] 우선순위(대화 중/대기/리액션) 상태머신 존재 여부

> Cursor 프롬프트
> - "감정/행동을 Live2D 표정/모션으로 바꾸는 코드 경로를 찾아서, 입력→처리→출력 과정을 단계별로 설명해줘."
> - "매핑 테이블(감정→표정, 행동→모션)이 있으면 파일 형태와 예시를 보여줘."

---

## 7. Unity 레포에서 “가져다 쓸 코드 구간” 추출(필수)

> 목표: 우리 프로젝트에 바로 반영 가능한 구간을 파일 단위로 뽑는다.

체크 항목:
- [ ] (A) 네트워크 연결: Unity→백엔드(HTTP/WebSocket)
- [ ] (B) 마이크 입력/오디오 처리
- [ ] (C) Live2D 제어(표정/모션/파라미터)
- [ ] (D) 대사 UI(말풍선/자막/로그)
- [ ] (E) 이벤트/상태관리(Idle/Talk/React 등)

산출물:
- [ ] "즉시 재사용 Top5" 목록 (파일 경로 + 왜 유용한지 1줄)

> Cursor 프롬프트
> - "Unity 레포에서 LLM 연동/네트워크/오디오/Live2D 제어와 관련된 스크립트를 찾아서 파일 목록을 만들고, 각 파일의 역할을 1~2줄로 요약해줘."
> - "우리 Unity 데스크탑 비서 앱에 바로 가져다 쓸 만한 코드 Top5를 추천해줘(근거 포함)."

---

## 8. 우리 프로젝트 적용 시나리오 결정

### 8-1. 적용안 A: 백엔드(메인 레포) v1.2.0을 별도 서비스로 사용

- Unity 앱 ↔ (로컬) 백엔드 프로세스
- 통신: HTTP/WebSocket
- 장점: LLM/STT/TTS 파이프라인 재사용 극대화
- 단점: 배포 복잡도(설치/실행/권한)

확인:
- [ ] 백엔드가 서버 모드로 쉽게 켜지는가?
- [ ] 설정 파일로 Provider/API Key 바꾸기 쉬운가?

### 8-2. 적용안 B: Unity 레포의 캐릭터/오디오/연동 구조만 차용

- LLM 호출은 우리 서버/경량 모듈로 단순화
- 장점: MVP 빠름
- 단점: STT/TTS는 나중으로 미룸

### 8-3. 적용안 C: 아이디어만 참고 (코드 재사용 최소)

- 라이선스/복잡도/의존성 때문에 참고만

> 결론 체크
- [ ] A / [ ] B / [ ] C 중 선택 + 이유

---

## 9. “반드시 답해야 할 질문 10개”(체크리스트)

- [ ] Q1. v1.2.0 MIT 확정인가? (파일/태그/커밋)
- [ ] Q2. Unity 레포 MIT 확정인가?
- [ ] Q3. LLM 출력이 구조화(JSON) 가능한가? 어떤 스키마인가?
- [ ] Q4. 감정/행동 태그가 실제로 Live2D 모션/표정으로 매핑되는가?
- [ ] Q5. 매핑 데이터는 어디에 있고, 우리가 교체 가능한가?
- [ ] Q6. STT/TTS는 어떤 조합이며 인터럽트가 가능한가?
- [ ] Q7. Unity↔백엔드 통신 구조는 무엇인가?
- [ ] Q8. 우리 “데스크탑 항상위+투명창”과 충돌 요소가 있는가? (UI 구조)
- [ ] Q9. 우리 MVP에 바로 가져올 수 있는 코드 Top5는 무엇인가?
- [ ] Q10. 최종 결론: 상용 MVP에 채택 가능한 전략은 무엇인가?

---

## 10. 노션 공유용 요약 템플릿(분석 후 채우기)

- 한 줄 요약:
- 라이선스 결론(안전 기준점):
- 즉시 재사용 Top5 (파일 경로 + 한 줄):
- 참고만 할 요소 Top5:
- 리스크(배포/의존성/라이선스):
- 우리 적용안 결론(A/B/C):
- 다음 액션(PoC):
